#ifndef MOTORCONTROLLER_H
#define MOTORCONTROLLER_H

#include <Arduino.h>

class MotorController {
  private:
    float kp, ki, kd;
    unsigned long t, t_prev;
    volatile long EncoderCount;
    const byte interruptPinA, interruptPinB;
    const byte PWMPin, DirPin1, DirPin2;
    volatile unsigned long count, count_prev;
    float Theta, RPM, RPM_d;
    float Theta_prev;
    int dt;
    float RPM_max;
    float Vmax, Vmin, V;
    float e, e_prev, inte, inte_prev;

  public:
    MotorController(byte encA, byte encB, byte pwmPin, byte dirPin1, byte dirPin2, float kpVal, float kiVal, float kdVal)
      : interruptPinA(encA), interruptPinB(encB), PWMPin(pwmPin), DirPin1(dirPin1), DirPin2(dirPin2), kp(kpVal), ki(kiVal), kd(kdVal) {
        t = t_prev = 0;
        EncoderCount = 0;
        count = count_prev = 0;
        Theta_prev = 0;
        RPM_max = 230;
        Vmax = 6;
        Vmin = -6;
        V = 0.1;
        e = e_prev = inte = inte_prev = 0;
    }

    void initializeMotor() {
      pinMode(interruptPinA, INPUT_PULLUP);
      pinMode(interruptPinB, INPUT_PULLUP);
      attachInterrupt(digitalPinToInterrupt(interruptPinA), ISR_EncoderA, CHANGE);
      attachInterrupt(digitalPinToInterrupt(interruptPinB), ISR_EncoderB, CHANGE);
      pinMode(DirPin1, OUTPUT);
      pinMode(DirPin2, OUTPUT);
    }

    void updatePIDControl() {
      if (count > count_prev) {
        t = millis();
        Theta = EncoderCount / 900.0;
        dt = (t - t_prev);
        RPM_d = RPM_max * (sin(2 * pi * 0.005 * t / 1000.0)) * sign(sin(2 * pi * 0.05 * t / 1000.0));
        if (t / 1000.0 > 100) {
          RPM_d = 0;
        }
        RPM = (Theta - Theta_prev) / (dt / 1000.0) * 60;
        e = RPM_d - RPM;
        inte = inte_prev + (dt * (e + e_prev) / 2);
        V = kp * e + ki * inte + (kd * (e - e_prev) / dt);
        if (V > Vmax) {
          V = Vmax;
          inte = inte_prev;
        }
        if (V < Vmin) {
          V = Vmin;
          inte = inte_prev;
        }

        WriteDriverVoltage(V, Vmax);

        Serial.print(RPM_d); Serial.print(" \t");
        Serial.print(RPM); Serial.print(" \t ");
        Serial.print(V); Serial.print("\t  ");
        Serial.print(e); Serial.println("  ");

        Theta_prev = Theta;
        count_prev = count;
        t_prev = t;
        inte_prev = inte;
        e_prev = e;
      }
    }

    void WriteDriverVoltage(float V, float Vmax) {
      int PWMval = int(255 * abs(V) / Vmax);
      if (PWMval > 255) {
        PWMval = 255;
      }
      if (V > 0) {
        digitalWrite(DirPin1, HIGH);
        digitalWrite(DirPin2, LOW);
      } else if (V < 0) {
        digitalWrite(DirPin1, LOW);
        digitalWrite(DirPin2, HIGH);
      } else {
        digitalWrite(DirPin1, LOW);
        digitalWrite(DirPin2, LOW);
      }
      analogWrite(PWMPin, PWMval);
    }

    float sign(float x) {
      if (x > 0) {
        return 1;
      } else if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    }

    // Interrupt Service Routines (ISRs)
    void ISR_EncoderA() {
      bool PinB = digitalRead(interruptPinB);
      bool PinA = digitalRead(interruptPinA);

      if (PinB == LOW) {
        if (PinA == HIGH) {
          EncoderCount++;
        } else {
          EncoderCount--;
        }
      } else {
        if (PinA == HIGH) {
          EncoderCount--;
        } else {
          EncoderCount++;
        }
      }
    }

    void ISR_EncoderB() {
      bool PinB = digitalRead(interruptPinA);
      bool PinA = digitalRead(interruptPinB);

      if (PinA == LOW) {
        if (PinB == HIGH) {
          EncoderCount--;
        } else {
          EncoderCount++;
        }
      } else {
        if (PinB == HIGH) {
          EncoderCount++;
        } else {
          EncoderCount--;
        }
      }
    }

};

#endif
